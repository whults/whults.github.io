---
layout:     post
title:      组会纪要
subtitle:   2023-11-03 组会纪要
date:       2023-11-03
author:    姚世豪
header-img: img/post-bg-desk.jpg
catalog: true
tags:
    - 组会
---

# 浏览器指纹

## 前置知识

### HTML

- HTML 一种用于定义内容结构的标记语言。
- HTML 通过不同的标签来标记不同的内容、格式、布局等
- `<img>` 标签表示一张图片；
- `<a>` 标签表示一个链接；
- `<table>` 标签表示一个表格；
- `<input>` 标签表示一个输入框；
- `<p>` 标签表示一段文本；
- `<strong>` 标签表示文本加粗效果；
- `<div>` 标签表示块级布局。

### CSS
- CSS 是一门样式表语言，这也就是说人们可以用它来选择性地为 HTML 元素添加样式。![图片1](https://whutslab.github.io/img/20231103/图片1.png)

### JavaScript
- JavaScript是一门完全的动态编程语言。当应用于 HTML 文档时，可以为网站提供动态交互特性。
- 开发者们基于 JavaScript 核心编写了大量实用工具，可以使 开发工作事半功倍。其中包括：
  - 浏览器应用程序接口（API）
  - 第三方 API —— 让开发者可以在自己的站点中整合其他内容提供者提供的功能。
  - 第三方框架和库 —— 用来快速构建网站和应用。

![image-20231110113230231](https://whutslab.github.io/img/20231103/image-20231110113230231.png)

### 浏览器指纹

- “浏览器指纹”是一种通过浏览器对网站可见的配置和设置信息来跟踪Web浏览器的方法。
- 信息熵是接收的每条消息中包含的信息的平均量，熵越高，则能传输越多的信息，熵越低，则意味着传输的信息越少。

## Web 追踪技术综述
王晓薇, 刘奇辉, 刘潮歌等.计算机研究与发展, 2023, 第60卷第4期

### 分类
- 存储型追踪技术

- Cookie 类存储技术

- HTML5 新型存储型API：
  - SessionStorage,
  - LocalStorage
  
- 指纹型追踪技术

  ![image-20231110113341601](https://whutslab.github.io/img/20231103/image-20231110113341601-16995872236172.png)

### 追踪范围
- 单浏览器追踪
- 含有较为丰富信息的特征：扩展、字体、历史记录、浏览器缓存等。
- 较为稳定的高级追踪特征：Canvas指纹、WebGL指纹、Audio指纹等。
- 跨浏览器追踪
- 基于硬件信息的设备追踪：GPU 特征信息、CPU 特征信息等。
- 基于网络信息的设备追踪：公网出口IP、内网IP 和内网拓扑信息等。
- 基于缓存信息的设备追踪：缓存中的敏感地理位置、DNS 缓存等。
- 跨设备追踪
- 确定性追踪：邮箱、手机号等登录账户。
- 概率性追踪：分析用户历史记录、行为等信息，统计学上的关联。

### Web追踪防御技术
- 扩展防御：Latex Gloves、Canvas Blocker
- 浏览器内嵌防御：FPRandom
- 防御框架、工具或机制：UNIGL
- 防御对策或环境：CloakX

### 挑战与展望--追踪技术
- 指纹关联分析方面的研究较为缺乏。
- 概率性的跨设备追踪在结合Cookie 类存储标识的前提下会更加有效和稳定。
- Web 追踪防御技术可能会使浏览器更容易被识别。
- 分析指纹追踪的有效性需要一个或多个较大的指纹数据集。
- 在保证指纹唯一性的同时对特征进行评估和选择优选，避免收集过多特征对数据传输和存储造成的压力。
- 指纹追踪特征研究应用：
  - 为不同的用户构建稳定且全面的用户画像
  - 辅助Web 安全领域针对 恶意数据进行分析
  - 对恶意行为的检测和追踪溯源

### 挑战与展望—防御形态
- 多数扩展的功能集中于抵御某项单一的指纹追踪方式
- 无法抵御使用多种特征追踪的指纹模式。
- 浏览器内嵌防御
- 推广和应用上面临巨大的困难。
- 工具和框架形态的防御
- 利用属性重组选择特征值的防御技术：消耗时间和减弱性能为代价；导致浏览器中出现较多的异常组合。
- 构建防御对策或环境
- 偏向于理想的防御方式，无法广泛地应用于实践。

### 挑战与展望—防御技术

- 随机化和引入噪音、属性重组、重写指纹值等
  - 生产了大量的虚假无效信息，消耗和占用服务资源
- 监控指纹追踪的属性获取情况，了解和控制可能被泄露或用来追踪的信息的输出和运行方式 
  - 无法做到全面和综合性的防御，对新追踪方式的自适应性不强
- 对不同的访问网站实现信息隔离
  - 对同一网站的持续性追踪具有较低的防御力
- 用户介入和参与
  - 无法做出较为有利的判断，降低良好的体验度

![image-20231110114445793](https://whutslab.github.io/img/20231103/image-20231110114445793-16995878875563.png)

### **挑战与展望——实现指纹防御的最佳状态**

在严格的浏览器模式和正常的浏览器功能之间取一个中和的方法，在不影响用户浏览体验的前提下，尽可能地将指纹信息一致化，且在每次启动浏览器或会话的时候，将IP等特殊的特征随机化。

## Fashion Faux Pas: Implicit Stylistic Fingerprintsfor Bypassing Browsers’ Anti-Fingerprinting Defenses

### 挑战

- 通常通过最先进的指纹识别方法收集的客户端特征很容易通过隐私增强防御通常采用的特征擦除和随机化技术进行修改。
- 重用通用 JavaScript API 和库的脚本化指纹方法使浏览器反指纹识别机制能够识别和解除指纹识别行为。
- 指纹识别技术或系统所产生的性能开销过大，可能对实际部署构成障碍。

### 工作动机

- 浏览器在不同的环境中渲染 HTML 元素的方式有所不同，因为它们的尺寸不仅由浏览器渲染引擎决定，还受到操作系统 (OS) 和其他环境因素的影响。 
- 虽然这种渲染差异可能很小，但维度数据足以区分设备。

![image-20231110123413022](https://whutslab.github.io/img/20231103/image-20231110123413022-16995908547094.png)

### 文章贡献

- 提出了风格浏览器指纹并开发了一种新颖的指纹识别系统StylisticFP，无需使用 JavaScript，该系统使用 CSS 以及精心构造和排列的 HTML 元素隐式推断出各种浏览器和系统特征。
- 针对流行的注重隐私的浏览器对系统进行了深入的实证评估，并探讨了本文系统在基于 JavaScript 的指纹识别技术失效的情况下如何有效。
- 进行了一项试点研究，展示了 CSS 驱动的指纹识别系统的功能和有效性。
- 向浏览器供应商披露了本文的发现，并根据要求与研究人员共享本文的系统。

### 设计难点

- 浏览器渲染页面时，必须能够动态获取指纹，而无需使用 JavaScript。 
- 选择具有区分能力的HTML元素，并且这些元素需要在屏幕上有策略地排列以保持稳定的指纹，并确保页面的性能不受影响。 
- 仅依赖 HTML 和 CSS 功能需要采用隐式方法来推断设备特征，这可能会导致难以克服的网络请求数量，需要精确的构造才能实现实际性能
- 需要一种有效的方法对 HTML 元素中的可用信息进行编码，以便服务器能够真正创建指纹。

### 收集维度

- 目标：获得多个元素的维度来推断设备信息
- CSS 媒体查询：使网站能够测试或检索设备的特性，而不管客户端上呈现的网页如何。
- 引入 iframe（内联框架）来欺骗媒体查询来测量元素的尺寸。
- iframe：用于将其他网页嵌入到当前页面中。

![image-20231110123617485](https://whutslab.github.io/img/20231103/image-20231110123617485-16995909794195.png)

- 使 iframe 的尺寸适应元素的尺寸。
- 将查询放置在 iframe 中。

下图显示了媒体查询的 CSS 语法。 该查询类似于 if/switch 语句，其中每个@media部分代表 if/case 语句中的不同分支。如果媒体块中满足条件，则触发块。

![image-20231110123725868](https://whutslab.github.io/img/20231103/image-20231110123725868-16995910492306.png)

在示例中，如果 iframe 的最小宽度为 301px，则会触发第二个块，客户端浏览器向服务器发出回调请求，请求带有精心设计的 url 的相应背景图片，通知服务器 iframe 的宽度为 301px。 如果维度与查询中列出的任何值都不匹配，则不会发生回调请求。 对于部署的每个 iframe，我们都会创建一个带有候选宽度和高度的查询媒体块列表，以探测 iframe 的尺寸。

iframe 的尺寸并不总是整数，也可以是小数，因为某些浏览器不会对媒体查询的数字进行四舍五入（例如 Firefox）。 因此，使用最小尺寸值来表示范围而不是精确值。（只能触发最后一个匹配的块）

#### 收集维度—示例

如图将一个 <textarea> 元素（第 2-4 行）和一个 <iframe> 放置在 <div> container中。 container的宽度取决于 <textarea> 元素的宽度，高度为 1000px。 假设我们通过媒体查询确定iframe的宽度为430px，高度为850px。 然后，我们可以得知 <textarea> 的宽度为 430px，高度为 150px。 

![image-20231110123821868](https://whutslab.github.io/img/20231103/image-20231110123821868-16995911035297.png)

### 指纹识别特征

 这个表详细介绍了风格指纹特征以及与其关联的 HTML 元素。 该系统共有 30 个指纹识别特征，使用 25 个 iframe 和 339 个 HTML 元素。

![image-20231110123914419](https://whutslab.github.io/img/20231103/image-20231110123914419-16995911559128.png)



下面这个表总结了这些指纹识别属性，其中包括通常由现有指纹识别方法（AmIUnique和FPJS）检测到的传统特征（例如浏览器供应商和操作系统）以及新特征（例如系统语言）。本文的特征选择以之前的工作以及探索性研究为指导，并添加了特定于风格或与风格相关的新特征。

![image-20231110123941788](https://whutslab.github.io/img/20231103/image-20231110123941788-16995911832119.png)

### 指纹特征--Environment

- 包含 HTML 元素参考指南中 101 种不同类型的元素。
- 排除主要浏览器不再支持的元素，以及可能导致问题的元素。
- 将 HTML 元素包装在 <noscript> 标记内来检测 JavaScript 是否被禁用，并使用 <canvas> 元素来确定禁用是否是由于浏览器设置所致。
- 在元素的文本中包含了九个带有特殊字符的元素，因为这些字符的渲染受到计算环境的影响。
- 使用 14 个 iframe，范围从 Env-1 到 Js-block config。

### 指纹特征--Fonts

- 利用两种类型的字体功能：字体首选项和支持的字体。
- 字体首选项：
  - 使用各种字体配置将文本嵌入到 26 个 <span> 元素中，并记录元素大小。
- 支持的字体:
  - 在浏览器中检查 52 种不同的字体族的支持，这些字体族源自 FingerprintJS 使用的列表 。
  - 使用 @font-face 定义了一组文章自己的字体族，这些字体族与现有的字体族相对应，并将它们分为三个阴影组。
- 使用九个 iframe，范围从表中的 Font-pref-1 功能到 Shadow-font-3。

### 指纹特征--Ad blocker presence

- 使用六个元素（三个 <img> 元素和三个 <div> 元素）作为广告元素，如果存在广告拦截器，则会诱使广告拦截器删除该元素。
- 两个元素请求远程资源，从而触发两个请求。
- 此类别中的 HTML 元素不使用任何专用 iframe，与其他组中的元素共享 iframe。

### 指纹特征--CSS media properties

- 使用 99 个媒体特征表达式测试测试从媒体查询级别 3 到 5 的23 个媒体属性。 每个表达式都使用一个 <div> 元素。 
- 其中包括：(i) 设备功能，例如每个颜色分量的位数和用于表示每个 CSS 像素的设备像素数，(ii) 浏览器首选项，例如浅色主题和简化手势，以及 (iii) 浏览器对最新 CSS 媒体功能及其配置的支持。下表总结了这些媒体属性
- 此类别使用两个 iframe

![image-20231110124936986](https://whutslab.github.io/img/20231103/image-20231110124936986-169959177818310.png)

### 性能优化--HTML元素排列

- 主 iframe：800px * 1000px 
- 网格布局：display: grid
- 将每组元素与 iframe 一起放置在容器的每一列中

将元素排列成对角组，从而大大减少 iframe 的数量，同时保留指纹熵。 具体来说，将特定类型的元素分组并将维度相加，从而避免信息丢失。 总共使用 25 组 HTML 元素的尺寸作为指纹属性。将所有元素放置在 800px x 1000px 的主 iframe中，以确保元素的尺寸在不同的屏幕分辨率下保持一致。

在主 iframe 中，使用 display: grid 创建一个具有网格布局的 div 容器。 我们将一组元素与 iframe 一起放置在容器的每一列中，这样 iframe 的数量对应于组的数量而不是元素的数量。 为了使用 iframe 获取多个元素的宽度和高度，我们进一步将列拆分为网格布局，并沿网格的对角线排列 HTML 元素。 子列的数量等于该组中元素的数量，子行的数量等于元素数量加一。 第一个元素位于第一个子行和第一个子列，第二个元素位于第二个子行和第二个子列，第三个元素位于第三个子列和子行，依此类推 。 此列中的 iframe 位于最后一个子行并跨越所有子列。

在每一列中，元素宽度的总和等于 iframe 的宽度，元素高度的总和等于 1000px 减去 iframe 的高度。

![image-20231110125036385](https://whutslab.github.io/img/20231103/image-20231110125036385-169959183773611.png)

### 性能优化--HTML元素分组

- 根据所区分的属性进行分组。
- 目的：最大化该容器在识别特定环境特征时的熵，并满足主 iframe 的高度限制。
- 对特定环境特征分组时：组中的元素可能对单个功能敏感，并且所有组的渲染都基于关于一些共同特征。
- 每组中的元素数量各不相同。

### 性能优化--字体指纹识别

- 基于 CSS 的字体指纹识别的简单算法
  - 直接使用 @font-face 规则检查每个字体族，从而产生多达 52 个 CSS 媒体查询请求。
- 基于元素尺寸的字体指纹识别方法
  - 该方法不依赖于 @font-face 请求。
  - 为每个<span> 元素分配一个字体系列和两个后备字体（Arial Black 和 Arial ）。如果测试字体系列可用，则该元素不会使用后备字体并以不同的大小呈现。如果测试字体系列可用，则该元素不会使用后备字体并以不同的大小呈现。 这种方法可以防止大量请求，并且不受字体系列名称冲突的影响，特别是对于非系统字体。 当用户下载并安装了给定字体系列的自定义实现时，可能会发生此类冲突。

### 性能优化—媒体属性

- 部署两组元素来测试媒体属性。
- 第一组中，使用 23 个 <div> 元素探测浏览器对 23 种媒体功能的支持
  - 𝛴_(ⅈ=1)^(𝑛−1) 𝑏_𝑖∗2^ⅈ，也就是1010101这种形式。
  - 使用 单个 iframe。
- 第二组总共有 76 个关注的媒体特征值，
  - 再次使用单个 iframe 将其编码在 <div> 元素中。
  - 每个元素的宽度值因表达式而异，而高度始终是固定值。
  - 当满足表达式时，iframe 的高度会减少固定值，而宽度会增加可变量。高度之和表示满足特征表达式的数量，而宽度之和则区分满足特征表达式的集合。 以这种方式对数据进行编码可以告诉我们有多少表达式得到满足，并提供宽度值的一些变化。 虽然编码不如第一组那么精确，但它确实给了的指纹更多的熵。

### 框架部署

- 具有数据库后端的独立 Web 服务
- 可以无缝集成到 Web 应用程序中。
- 部署不依赖于目标站点，并且与底层 Web 框架和基础设施无关。 
- 仅需要一行 HTML 标记来嵌入其主 iframe 对象，并且所有后续指纹有效负载都直接发送到后端。
- 可以使用许多技术来使 iframe 对用户不可见。
- 设备特征是根据收集的维度数据推断的，这些数据揭示了有关设备的信息，并被组合成用于唯一标识设备的标识符。

### 威胁模型

- 攻击者能够欺骗用户访问指纹识别网站。
- 攻击者可以将一行 HTML 代码注入合法网页来将包含指纹识别的负载包含在用户响应中。
- 攻击者可以利用中间人代理服务将指纹识别代码注入代理的 Web 响应中。

### 绕过防御的能力

作者分析的重点是当下比较流行的浏览器和工具，这些浏览器和工具实施了针对指纹识别的隐私保护对策。作者测试了多个版本的操作系统和浏览器，并尝试对系统配置进行不同的更改，以评估风格指纹是否捕捉到更新的特征。

下表显示了风格指纹识别属性及其针对流行对策的有效性：✓表示有效，✗表示它无效，⊕表示它部分有效。图中大部分还是有效的

![image-20231110125629401](https://whutslab.github.io/img/20231103/image-20231110125629401-169959219308712.png)

### 绕过防御—Brave浏览器举例

- 反语言指纹识别
  - 防御：减少和随机化 navigator.language 和 navigator.languages API 以及 Accept-Language 头部中的可用信息。
  - 绕过：不会直接获取浏览器语言偏好，而是通过观察与语言相关的 iframe 的维度来确定操作系统语言。
- 反字体指纹识别
  - 防御：在每次会话期间从浏览器的字体族列表中随机删除条目。
  - 绕过：加载本地字体文件来检查用户设备上是否有可用的字体。

[示例视频]: https://vimeo.com/739534811/c6f294458d

### 测试—系统开销

- 将StylisticFP与 FingerprintJS 进行比较，图中展示了实验结果的分布函数：

  - 测试三种场景：每个系统的独立部署以及两个工具的组合部署。
  - 环境：在2019 MacBook Pro i9上运行 Chrome 

  

- 仅产生 83 个网络请求

  - 亚马逊的主页： 300 多个请求
  - Facebook 的 feed ：大约 230 个请求

![image-20231110130007343](https://whutslab.github.io/img/20231103/image-20231110130007343-169959240855813.png)

### 试点研究

- 时间跨度：9 周
- 方法：在大型组织托管的三个不同在线门户上部署了本文的指纹识别系统。这些门户只有在身份验证后才能访问。这样可以设置一个带有随机字符串的 HTTP cookie 用于区分设备。
- 度量：与最新版本（v3）的 FingerprintJS (FPJS) 比较唯一识别设备的能力。
- 该研究的人群由计算机科学家组成，在浏览器选择或配置方面可能比较具有同质性。 并且随着试点研究的公布，某些操作也可能偏离正常的用户行为，并有用户故意修改其环境来测试系统。

![image-20231110130044069](https://whutslab.github.io/img/20231103/image-20231110130044069-169959244512014.png)

- 无法识别设备：
  - StylisticFP：41 个设备
  - FPJS ：188 个设备
- 指纹冲突
  - StylisticFP ：95 次设备冲突
  - FPJS：55 次设备冲突
- 原因分析：
  - StylisticFP：广告拦截器扩展、JS禁用和浏览器显示模式等，在不同访问中被更改。
  - FPJS：ScreenFrame和canvas属性在访问过程中不稳定、属性的随机化、阻止JS等。

### StylisticFP 防御策略

- 禁用 iframe：Auto Iframes Remover等浏览器扩展
- 阻止媒体查询：报告一些媒体功能的虚假值
- 动态监控对服务器端资源的请求
- 添加噪音：将随机 CSS 属性应用于指纹元素
- 静态分析：检查链式媒体查询