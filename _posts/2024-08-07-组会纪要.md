# 基本信息
| # **文献阅读记录表**
 |  |
| --- | --- |
| **论文题目** | KIT: Testing OS-Level Virtualization for Functional Interference Bugs |
| **作者** | Congyu Liu, Sishuai Gong and Pedro Fonseca |
| **年份** | 2023 |
| **文献类型** | 会议论文（ASPLOS '23: 28th ACM International Conference on Architectural Support for Programming Languages and Operating Systems, Volume 2）（CCFA） |
| **关键词** | OS-level virtualization, software testing |
| **摘要** | 容器隔离是通过操作系统级别的虚拟化来实现的，比如Linux namespaces。但是，这些机制很难正确实现，并且在实践中，还会出现**功能干扰错误（functional interference bugs）**，从而危及容器安全性。具体而言，功能干扰bug允许攻击者从同一台机器上运行的另一个容器中提取信息，或者通过修改错误隔离的内核资源来影响其完整性。尽管存在影响，但操作系统虚拟化中的功能干扰bug受到的关注有限，部分原因是在检测她们方面存在挑战。许多功能干扰bug不会导致内存错误或者崩溃，而是涉及难以捕获的逻辑错误，这些错误会悄无声息地产生语义错误。
本文提出了KIT，一种动态监测框架，可以在操作系统级的虚拟机制中发现功能干扰bug，比如Linux namespace。KIT的核心思想是通过比较容器在两次执行中的系统调用跟踪来检测容器间的功能干扰，其中容器在两次执行中运行，并且在另一个容器的先执行和不执行的情况下运行。为了提高效率和准确性，KIT包含了两个重要的组件：一个高效的算法，用于生成执行容器间数据流的测试用例；一个系统调用分析框架，用于检测功能干扰bug和集群bug报告。KIT在Linux内核5.15中发现了9个功能干扰bug，其中6个已经被确认了。所有的bug都是由于逻辑错误导致的，这表明该方法能用于检测难以捕获的语义bug。 |
| **主要贡献** | 
1. 提出了一种通用的动态测试技术，用于发现操作系统级虚拟化中的功能干扰错误
   1. 利用给予分析的内核数据流离生成鼓励容器间内核数据流动的测试用例
   2. 通过新颖的测试用例执行和系统调用跟踪方法来检测功能干扰bug
2. 一种防止假阳性（误报）的方法
   1. 过滤基于输入规范的不相关系统调用结果
   2. 通过测试重新执行过滤不确定性系统调用
3. 一种聚类技术，通过根据所涉及的罪魁祸首发送方和接收方系统调用对聚合测试报告来避免冗余测试报告。
4. 实现KIT：用于 Linux 命名空间子系统的实用动态测试框架

[GitHub - rssys/kit: Kernel isolation tester.](https://github.com/rssys/kit)
5. 对KIT的评估，发现 Linux 命名空间子系统中存在 9 个功能干扰 bug，其中 3 个已在上游修复。
 |
| **挑战** | 内核资源隔离的挑战：
1. 大量可用的内核资源（socket, file and timers)
2. 实现内核资源隔离需要添加逻辑检查，这些检查通常深入内核内部和每个资源访问实例，已验证是否允许容器访问资源。

功能干扰错误检测的挑战：
1. 通常是由于难以捕获的逻辑错误引起的，这些错误不会导致立即失

KIT实现的挑战：
1. 需要生成可能触发功能干扰bug的测试用例（怎么那么像fuzz呢？）
2. 必须在不产生可能妨碍框架实际可用性的误报情况下进行系统调用结果比较
 |
| **研究创新** | KIT：一个动态测试框架，用于系统地测试操作系统级虚拟化机制的功能干扰。
用fuzz发现容器间功能干扰 |

# 笔记
## introduction
功能干扰错误（functional interference bug）：可能导致跨容器信息泄露、拒绝服务攻击和权限提升攻击。
在多租户环境下，不正确或者不充分的内核隔离会导致严重的容器安全问题：

1. 不正确的隔离可能会让攻击者了解在同一台机器上运行的另一个容器的凭据，这可能会进一步导致对其他网络可访问系统的级联攻击

![KIT功过执行两次receiver程序来检测功能干扰（白底执行sender/黑底不执行sender），并比较receiver在两次执行中的系统调用结果，以检测不同](https://cdn.nlark.com/yuque/0/2024/png/12987916/1720531834035-e10a7920-db2b-48df-a852-c0ec3530c774.png#averageHue=%23e6e6e6&clientId=u7ae75f99-0d34-4&from=paste&height=468&id=u870be253&originHeight=936&originWidth=1130&originalType=binary&ratio=2&rotation=0&showTitle=true&size=151566&status=done&style=none&taskId=uf4561f5f-5195-45aa-a9ec-6c173b2fa6d&title=KIT%E5%8A%9F%E8%BF%87%E6%89%A7%E8%A1%8C%E4%B8%A4%E6%AC%A1receiver%E7%A8%8B%E5%BA%8F%E6%9D%A5%E6%A3%80%E6%B5%8B%E5%8A%9F%E8%83%BD%E5%B9%B2%E6%89%B0%EF%BC%88%E7%99%BD%E5%BA%95%E6%89%A7%E8%A1%8Csender%2F%E9%BB%91%E5%BA%95%E4%B8%8D%E6%89%A7%E8%A1%8Csender%EF%BC%89%EF%BC%8C%E5%B9%B6%E6%AF%94%E8%BE%83receiver%E5%9C%A8%E4%B8%A4%E6%AC%A1%E6%89%A7%E8%A1%8C%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%BB%93%E6%9E%9C%EF%BC%8C%E4%BB%A5%E6%A3%80%E6%B5%8B%E4%B8%8D%E5%90%8C&width=565 "KIT功过执行两次receiver程序来检测功能干扰（白底执行sender/黑底不执行sender），并比较receiver在两次执行中的系统调用结果，以检测不同")
## background and motivation
### Linux Namespaces
![image.png](https://cdn.nlark.com/yuque/0/2024/png/12987916/1720533588200-2fe26d42-0de9-4005-9b3a-8a6baf7a87a9.png#averageHue=%23efefef&clientId=u7ae75f99-0d34-4&from=paste&height=243&id=u30e5bd01&originHeight=486&originWidth=964&originalType=binary&ratio=2&rotation=0&showTitle=false&size=78186&status=done&style=none&taskId=u5fb37666-64e5-495b-ba99-b5cebebde26&title=&width=482)
通过unshare系统调用来创建和加入一个命名空间，一个namespace实例可以分配给一个进程或一组进程。
通过setns系统调用可以从一个命名空间切换到另一个命名空间。
通过clone系统调用，父进程可以指定子进程的命名空间，不指定则继承父进程的命名空间。
### Testing Kernel Resource Isolation

1. 通过比较主机和容器的procfs和sysfs中的统一文件来检测信息泄漏，但无法发现其他内核接口中的信息泄露。
2. 静态分析方法来发现容易受到基于容器的拒绝服务攻击的内核抽象资源，但静态分析在大型和复杂的系统中很难发挥作用
### Functional Interface Detection
目标：找到允许信息泄露和完整性攻击的内核隔离漏洞
使用功能干扰作为容器漏洞检测器：这种方法的目的不是在内核执行过程中查找内部错误，而是**检测内核产生错误输出的证据**
## Practical Functional Interference Testing
解决了两个难题：高效的测试用例生成和有效的功能干扰错误检测。
### Efficient Test Case Generation
功能干扰的根本原因是共享内核内存上的容器间通信，也就是说一个容器（sender）只有在修改内核共享内存区域时，才能干扰另一个容器（receiver）。
### Effective Functional Interference Bug Detection
检测方法：分析receiver程序在执行sender程序和未执行sender程序时的执行轨迹。
判断方法：如果sender对receiver造成了功能干扰的话，那么两次执行的系统调用轨迹会不同。
优化方法（减少误报）：

- 功能干扰发生在不受明明空间保护的资源上（不检测）：与用户交互，由用户提供部分过滤规则。
- 由非确定性引起的系统调用轨迹差异（不报告）：多次运行receiver程序，识别并忽略非确定性系统调用结果。
> what is 非确定系统调用？

## KIT Design
![四个阶段](https://cdn.nlark.com/yuque/0/2024/png/12987916/1720600120764-895e7e4b-42b2-421b-998b-77d7ebf20c34.png#averageHue=%23e7e7e7&clientId=u46d83501-56e5-4&from=paste&height=162&id=u9ac2163c&originHeight=324&originWidth=2320&originalType=binary&ratio=2&rotation=0&showTitle=true&size=88884&status=done&style=none&taskId=uf96788a5-15d2-4ec4-a76a-da70cadfd45&title=%E5%9B%9B%E4%B8%AA%E9%98%B6%E6%AE%B5&width=1160 "四个阶段")

1. 生成测试用例：
> 输入：内核测试程序（系统调用序列），可由fuzzer等外部工具生成
> 输出：触发功能干扰的测试用例，每个测试用例都由sender程序和receiver程序组成
> - sender程序：修改本应隔离的内核资源
> - receiver程序：检测对这些内核的修改（好像侧信道啊！！）
> 
步骤：
> 1. 发现容器间数据流：使用动态数据流分析，对每个测试程序触发的内存访问进行剖析，然后找到**触发对相同内存位置的写入和读取访问的程序对**。
> 2. 优先触发独特内核行为的测试用例（回报率高）
> 3. 使用多种启发式方法对可能触发相同内核行为的测试用例进行聚类，每个聚类只执行一个测试用例以提高效率。根据测试用例触发的潜在容器间内核数据流的属性来聚类相似的测试用例。如果两个测试用例能引起类似的容器内核间数据流，那么它们很可能会触发相同的功能干扰错误。
>    1. DF-IA：涉及类似的写入和读取内核指令
>    2. DF-ST：DF-IA的拓展，还考虑了执行写入和读取指令的调用栈

2. 执行测试用例
> KIT 使用虚拟机快照（保证执行环境相同），在不同的容器中运行每个测试程序

两次执行：	  （1）a容器中执行sender后b容器中再执行receiver
（2）a容器中不执行sender，b容器中执行receiver
收集系统调用跟踪：系统调用的执行结果，包括参数、返回值和错误编码

3. 分析跟踪结果

识别访问受保护资源的系统调用：用户设置的规则
识别非确定性结果：
> 有些系统调用的部分结果是非确定的，而部分结果是确定的：fstat 系统调用不仅会产生时间戳等非确定性结果，还会产生文件大小等确定性结果。

**细粒度的跟踪比较算法：**该算法比较两个系统调用跟踪的抽象语法树（AST），并报告树的差异。通过比较抽象语法树的差异，而不是比较纯系统调用跟踪文本，可以识别或忽略细粒度系统调用结果的差异。
![比较两个跟踪文本，该算法递归遍历两个 AST（第 6-8 行），并在两个树节点不匹配时报告差异（第 4-5 行）。具体来说，每个节点都有一个 det 标志，用于指定当前节点及其子树所代表的系统调用结果是否具有确定性。在比较过程中，如果两个树节点中的一个包含一个设置为 false 的 det 标志，那么这两个节点之间的差异将被忽略，它们的子树遍历将停止（第 2 行）。](https://cdn.nlark.com/yuque/0/2024/png/12987916/1720601244316-304f2573-ea30-4a95-8c37-39bf49328af8.png#averageHue=%23efefef&clientId=u46d83501-56e5-4&from=paste&height=310&id=mUuer&originHeight=620&originWidth=1124&originalType=binary&ratio=2&rotation=0&showTitle=true&size=139534&status=done&style=none&taskId=u0b4262a2-3795-4bf2-8bb8-af250fa40d7&title=%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E8%B7%9F%E8%B8%AA%E6%96%87%E6%9C%AC%EF%BC%8C%E8%AF%A5%E7%AE%97%E6%B3%95%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E4%B8%A4%E4%B8%AA%20AST%EF%BC%88%E7%AC%AC%206-8%20%E8%A1%8C%EF%BC%89%EF%BC%8C%E5%B9%B6%E5%9C%A8%E4%B8%A4%E4%B8%AA%E6%A0%91%E8%8A%82%E7%82%B9%E4%B8%8D%E5%8C%B9%E9%85%8D%E6%97%B6%E6%8A%A5%E5%91%8A%E5%B7%AE%E5%BC%82%EF%BC%88%E7%AC%AC%204-5%20%E8%A1%8C%EF%BC%89%E3%80%82%E5%85%B7%E4%BD%93%E6%9D%A5%E8%AF%B4%EF%BC%8C%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E9%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%20det%20%E6%A0%87%E5%BF%97%EF%BC%8C%E7%94%A8%E4%BA%8E%E6%8C%87%E5%AE%9A%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9%E5%8F%8A%E5%85%B6%E5%AD%90%E6%A0%91%E6%89%80%E4%BB%A3%E8%A1%A8%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%BB%93%E6%9E%9C%E6%98%AF%E5%90%A6%E5%85%B7%E6%9C%89%E7%A1%AE%E5%AE%9A%E6%80%A7%E3%80%82%E5%9C%A8%E6%AF%94%E8%BE%83%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%A4%E4%B8%AA%E6%A0%91%E8%8A%82%E7%82%B9%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AA%E8%AE%BE%E7%BD%AE%E4%B8%BA%20false%20%E7%9A%84%20det%20%E6%A0%87%E5%BF%97%EF%BC%8C%E9%82%A3%E4%B9%88%E8%BF%99%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82%E5%B0%86%E8%A2%AB%E5%BF%BD%E7%95%A5%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E5%AD%90%E6%A0%91%E9%81%8D%E5%8E%86%E5%B0%86%E5%81%9C%E6%AD%A2%EF%BC%88%E7%AC%AC%202%20%E8%A1%8C%EF%BC%89%E3%80%82&width=562 "比较两个跟踪文本，该算法递归遍历两个 AST（第 6-8 行），并在两个树节点不匹配时报告差异（第 4-5 行）。具体来说，每个节点都有一个 det 标志，用于指定当前节点及其子树所代表的系统调用结果是否具有确定性。在比较过程中，如果两个树节点中的一个包含一个设置为 false 的 det 标志，那么这两个节点之间的差异将被忽略，它们的子树遍历将停止（第 2 行）。")

4. 汇总测试报告

特定的功能干扰案例通常只能由特定的发送方和接收方系统调用触发和检测。
为了找出发送方系统调用的根本原因，KIT 采用了一种差异测试方法：对于发送方程序中的每个系统调用，KIT 都会检查在执行过程中跳过该发送方调用是否会掩盖功能干扰。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/12987916/1720602185574-61ec59b0-01ce-4c90-93b1-f582e7f0690a.png#averageHue=%23f1f1f1&clientId=u46d83501-56e5-4&from=paste&height=418&id=ud0f8079f&originHeight=836&originWidth=1146&originalType=binary&ratio=2&rotation=0&showTitle=false&size=159274&status=done&style=none&taskId=u9f5d3b4d-06b0-4d69-8b07-f19d39b5f1c&title=&width=573)
## Implementation

1. 测试用例执行器：基于Syzkaller实现
> Syzkaller：google的安全研究人员开发并维护的内核fuzz工具
> [https://github.com/google/syzkaller](https://github.com/google/syzkaller)

2. 系统调用识别：通过 Syzlang Syzkaller 的系统调用描述框架实现的
